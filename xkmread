#!/usr/bin/env python

import sys
import struct

XkbNumVirtualMods = 16

XkmSectionTypes = ["XkmTypesIndex",
                   "XkmCompatMapIndex",
                   "XkmSymbolsIndex",
                   "XkmIndicatorsIndex",
                   "XkmKeyNamesIndex",
                   "XkmGeometryIndex",
                   "XkmVirtualModsIndex"]

def usage(exitcode = 0):
    import os
    print os.path.basename(__file__) + " file.xkm"
    sys.exit(exitcode)

class InvalidXKMFile:
    def __init__(self, reason):
        self.reason = reason

    def __str__(self):
        return self.reason

class Indent:
    def __init__(self, shiftwidth=4):
        self.indent = ""
        self.shiftwidth = shiftwidth
    def push(self):
        self.indent += " " * self.shiftwidth
    def pop(self):
        self.indent = self.indent[:-self.shiftwidth]
    def get(self):
        return self.indent

indent = Indent()

# Return number of bytes needed to padd 'bytes' to 4-byte units
def pad4(bytes):
    return (((bytes + 3) >> 2) << 2) - bytes

# XKM uses counted strings, a 16-bit number describes the length of the
# string, string follows after. The whole lot is 4-byte padded.
def xkm_read_string(buffer):
    string = None

    l = struct.unpack("H", buffer.read(2))[0]
    if l > 0:
        string = struct.unpack("%ds" % l, buffer.read(l))[0]
        pad = pad4(l + 2)
        if pad > 0:
            buffer.read(pad)
    return string

def type_to_str(val):
    s = ""
    if val.__class__ == list:
        indent.push()
        for v in val:
            s += type_to_str(v) + ", "
        if len(val) > 0:
            s = s[:-2] # strip last ', '
        indent.pop()
    elif val.__class__ == dict:
        s += "\n"
        indent.push()
        for k in val.keys():
            s += indent.get() + "%s: %s\n" % (k, type_to_str(val[k]))
        indent.pop()
    else:
        s = str(val)
    return s

# How this works:
#   - Subclasses of XkmSection need to initialize self.field[] in the order of
#   the subfields of the section. Best during __init__
#   - Subclasses of XkmSection need to init self.format and self.struct_size
#   Once that's set up, the class can just call .unpack() on the file/buffer
#   and it will set itself up with member variables according to the field
#   names.
class XkmSection:
    def __init__(self):
        self.special_output = {}

    def unpack(self, buffer):
        t = struct.unpack(self.format, buffer.read(self.struct_size))
        for val, key in zip(t, self.fields):
            self.__dict__[key] = val

    def __str__(self):
        str = indent.get() + "Section: %s\n" % self.__class__.__name__
        indent.push()
        for key in self.fields:
            val = self.__dict__[key]
            if self.special_output.has_key(key):
                val = self.special_output[key][val]

            str += indent.get() + "%s: %s\n" % (key, type_to_str(val))
        indent.pop()
        return str

class XkmSectionInfo(XkmSection):
    def __init__(self):
        XkmSection.__init__(self)
        self.fields = [
                "type",
                "format",
                "size",
                "offset"
                ]
        self.format = "HHHH"
        self.struct_size = struct.calcsize(self.format)
        self.special_output["type"] = XkmSectionTypes

class XkmVirtualMods(XkmSection):
    def __init__(self):
        XkmSection.__init__(self)
        self.vmods = XkbNumVirtualMods * [0]
        self.names = XkbNumVirtualMods * [""]
        self.fields = ["vmods", "names"]

    def unpack(self, buffer):
        bound, named = struct.unpack("HH", buffer.read(4))
        pad_needed = 0
        self.bound, self.named = bound, named

        for i in range(0,  XkbNumVirtualMods):
            if (bound & (1 << i)):
                vmod = struct.unpack("B", buffer.read(1))
                self.vmods[i] = vmod[0]
                pad_needed += 1

        if pad4(pad_needed) > 0:
            buffer.read(pad4(pad_needed))

        for i in range(0, XkbNumVirtualMods):
            if (named & (1 << i)):
                self.names[i] = xkm_read_string(buffer)

class XkmKeyTypeDesc(XkmSection):
    def __init__(self):
        XkmSection.__init__(self)
        self.fields = [
                "realMods",
                "numLevels",
                "virtualMods",
                "nMapEntries",
                "nLevelNames",
                "preserve",
                "preserve_type",
                "map_entries",
                "level_names"
                ]
        self.format = "BBHBBBB"
        self.struct_size = struct.calcsize(self.format)

    def unpack(self, buffer):
        XkmSection.unpack(self, buffer)
        self.map_entries = []
        for i in range(0, self.nMapEntries):
            # xkmKTMapEntry
            level, realmods, virtmods = struct.unpack("BBH", buffer.read(4))
            self.map_entries.append({
                "level" : level,
                "realmods" : realmods,
                "virtmods" : virtmods
                })

        self.kt_name = xkm_read_string(buffer)

        if self.preserve:
            # xkmModsDesc
            self.preserve_type = []
            for i in range(0, self.nMapEntries):
                realMods, pad, virtMods = struct.unpack("BBH", buffer.read(4))
                self.preserve_type.append({
                    "realMods" : realMods,
                    "virtMods" : virtMods})


        if self.nLevelNames:
            self.level_names = []
            for i in range(0, self.nLevelNames):
                self.level_names.append(xkm_read_string(buffer))

class XkmTypes(XkmSection):
    def __init__(self):
        XkmSection.__init__(self)
        self.num_types = -1
        self.fields = ["name", "num_types"]

    def unpack(self, buffer):
        self.name = xkm_read_string(buffer)
        self.num_types= struct.unpack("H", buffer.read(2))[0]
        self.type_descs = []
        buffer.read(pad4(2))
        for i in range(0, self.num_types):
            desc = XkmKeyTypeDesc()
            desc.unpack(buffer)
            self.type_descs.append(desc)

    def __str__(self):
        s = XkmSection.__str__(self)
        indent.push()
        for desc in self.type_descs:
            s += str(desc)
        indent.pop()
        return s



def xkm_read_sectioninfo(file):
    sect = XkmSectionInfo()
    sect.unpack(file)
    print "%s" % sect

    return sect

def xkm_read_section(file, section):
    pos = file.tell()
    file.seek(section.offset)

    # for some reason, the XkmSectionInfo seems to be here again.
    XkmSectionInfo().unpack(file)

    sect = None
    if section.type == XkmSectionTypes.index("XkmVirtualModsIndex"):
        sect = XkmVirtualMods()
        sect.unpack(file)
    elif section.type == XkmSectionTypes.index("XkmTypesIndex"):
        sect = XkmTypes()
        sect.unpack(file)

    print "%s" % sect

    file.seek(pos)

def xkm_read_TOC(file):
    version, m, k, x = struct.unpack('Bccc', file.read(4))
    if x + k + m != "xkm":
        raise InvalidXKMFile("Not an XKM file.")

    print "XKM file version %d." % version

    type, min_keycode, max_keycode, ntoc, present, pad = struct.unpack('BBBBHH', file.read(8))
    print "File info:"
    print "    Type: %d" % type
    print "    Keycode range: %d-%d" % (min_keycode, max_keycode)
    print "    Number of sections: %d" % ntoc
    print "    Present: %d" % present

    sections = []
    for i in range(0, ntoc):
        indent.push()
        sections.append(xkm_read_sectioninfo(file))
        indent.pop()

    for section in sections:
        xkm_read_section(file, section)



def xkm_read(file):
    xkm_read_TOC(file)


if __name__ == "__main__":
    if len(sys.argv) < 2:
        usage(1)

    filename = sys.argv[1]
    file = open(filename, "rb")
    if not file:
        print "Cannot access %s" % filename
        sys.exit(1)

    try:
        xkm_read(file)
    except InvalidXKMFile as e:
        print "Failed to read file '%s'." % filename
        print "Reason: %s" % e

